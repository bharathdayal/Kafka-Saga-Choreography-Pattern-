package com.saga.payment;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.saga.kafka.KafkaProducerService;
import com.saga.kafka.entity.KafkaMessageLog;
import com.saga.kafka.entity.PaymentEventLog;
import com.saga.kafka.repository.KafkaMessageLogRepository;
import com.saga.kafka.repository.PaymentEventLogRepository;
import com.saga.kafka.service.KafkaMessageLogService;
import com.saga.model.Order;
import com.saga.model.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

@Component
public class PaymentListener {

    @Autowired
    private  KafkaProducerService producer;

    @Autowired
    private WebClient webClient;

    @Autowired
    private  PaymentEventLogRepository paymentEventLogRepository;



    public PaymentListener(KafkaProducerService producer,WebClient webClient) {
        this.producer = producer;
        this.webClient = webClient;
        this.paymentEventLogRepository = paymentEventLogRepository;

    }

    @KafkaListener(topics = "order-created", groupId = "paymentkafka")
    public void processPayment(Order order, Acknowledgment ack) {
        try {
            // Step 1: Save to DB to generate paymentId (UUID)
            PaymentEventLog savedLog = paymentEventLogRepository.save(
                    new PaymentEventLog(order.getOrderId(), "PENDING")
            );

            // Step 2: Build Payment object with DB-generated UUID
            Payment payment = new Payment(
                    savedLog.getPaymentId(), // UUID generated by DB
                    order.getOrderId(),
                    order.getProductId(),
                    "PENDING",
                    order.getOrderName()
            );
             System.out.println(payment);



            // Step 3: Call the /payments endpoint using WebClient
            webClient.post()
                    .uri("http://localhost:8091/payments") // Adjust port/path as needed
                    .bodyValue(payment) // Correct: send full Payment object
                    .retrieve()
                    .toBodilessEntity()
                    .doOnSuccess(response -> {


                        PaymentEventLog savedLogSuccess = paymentEventLogRepository.save(
                                new PaymentEventLog(payment.getPaymentId(),payment.getOrderId(), "PAID")
                        );


                        Payment paymentSuccess = new Payment(
                                savedLogSuccess.getPaymentId(), // UUID generated by DB
                                //UUID.randomUUID(),
                                order.getOrderId(),
                                order.getProductId(),

                                savedLogSuccess.getStatus(),
                                order.getOrderName()
                        );

                        // Step 4: Produce event to Kafka using paymentId as message key
                        //if(paymentSuccess.getStatus().equals("PAID")) {
                            if (!paymentEventLogRepository.existsByPaymentId(payment.getPaymentId()) && payment.getPaymentId() != null) {
                            producer.sendMessage("payment-processed", paymentSuccess, paymentSuccess.getStatus(), paymentSuccess.getOrderId(), paymentSuccess.getPaymentId());

                            System.out.println("payment-processed via WebClient for: " + order.getOrderName());

                            ack.acknowledge(); // CK only after full success
                        }
                    })
                    .doOnError(error -> {
                        System.err.println("Payment API failed: " + error.getMessage());
                        // Do not ack â€” Kafka will retry
                    })
                    .onErrorResume(error -> {
                        // Gracefully recover or return a fallback value
                        return Mono.empty();
                    })
                    .subscribe();

        } catch (Exception e) {
            System.err.println("Exception during WebClient payment call: " + e.getMessage());
            throw new RuntimeException(e); // Kafka will retry
        }
    }

  /*  @KafkaListener(topics = "order-created", groupId = "paymentkafka")
    public void processPayment1(Order order, Acknowledgment ack)  {


       try {
         // Call Rest API
           System.out.println("payment-processed for :" +order.getOrderName());
           ack.acknowledge();

       } catch (Exception e) {
           throw new RuntimeException(e);
       }
    }


   */

}




